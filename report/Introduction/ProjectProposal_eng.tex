\section{Project Proposal}
\subsection{Purpose}
In agile processes there is a great focus on that requirements is not something that you just make, but something that you discover and improve throughout the project.
To accommodate this method, there are different processes, with different ways accomplish it. 
Where Scrum, works with a so called "Product Owner", which is a person representing the customer, either by being the actual customer, or someone with knowledge and authority (domain expert) to make decisions on behalf of the customer. 
In Extreme Programming (XP) there is something similar, but called "Onsite Customer", which means that the customer must be present in the same room as the developers  and be available to answer questions and provide feedback on the quality of the product. 
\\\\
A common problem with both methods are that they require the customer leave their normal environment and be where the developers are. 
This means that the customer or domain expert will have to recall the problem domain, and not be present in it.
Since many of the details regarding the problem domain often comes as Tacit knowledge, which can make it hard to recall the details if the they are not problem domain. 

The optimal scenario would be if the customer or domain expert could fill their role as Product Owner, while he or she were in the proper domain. 

This would increase the quality of feedback.

It is also a well known problem that customers are terrible at saying what they want, but it is very easy for them to say what they do not want.
\\\\
A phenomenon which Morten from this group have worked a lot with his 5 years of experience as a designer.
In the world of design, to accommodate this problem you often present the customer with 3 proposals for designs, and ask the customer to point out what they like and do not like.
This gives the designer some insight into what the customer actually wants and likes. 
\\\\
With these two problems concerning inclusion of the customer in the development process, it would be exiting to look at which other technologies could be used, that could allow the customer to express their needs while being in their problem domain while still being able to communicate with the developers. 

\subsection{Execution}
We would like to create a mobile application which will allow the customer to express their needs in an intuitive and precise manner, which at the same time would allow the requirements to be translated to a set of "acceptance tests" which would allow the developers to verify that they have fulfilled the requirements of the customer.
This tool will also allow the developers to propose alternative solutions, not in the form of software implementations, but in the same environment as the customer. 
This will allow the customer to look at the different problem solutions whenever they like to, and all in the same environment that the customer uses to express their requirements. 
\\\\
The intention is to develop a platform that will use "Finite State Automata" to express needs, requirements and wishes to a product, in a way that is useful for people without formal knowledge of these. 

Using "Finite State Automata" will also allow for algorithms to highlight errors or oversights in the specified requirements.
The use of "Finite State Automata" will also make it possible to know every state of an application, and this means that it is possible to give guarantees that applications will not end in a unwanted state. 

Furthermore this would also allow that developers with far greater knowledge about "Finite State Automata" to communicate alternative solutions in a way that is transparent and understandable to the customer. 

These State Automatas will then be translated into acceptance tests though automatic code generation.

This will in the end allow the developer greater confidence in developing a product that fulfils the customers wishes, while also make it easier to get the development right the first time.
\\\\
We would like during the project to perform an experiment, with the proposed solution to test if the product could solve some of the problems.
To do this we would like to select some of the groups from the Giraf proect at Aalborg Universitet. 
Here we would act as a communication medium between the development teams (groups) and Product Owner.

Here we will start by creating paper prototypes of our idea, and see how communication and understanding will be affected by both customer (Product Owner) and developers (groups).

After this we would have to manually rewrite the paper prototype to "acceptance tests" in the project and see how it would be to have automatic "Definition of Done" affects developers ability to fulfil the requirements

By only using a subset of the groups from Giraf, we have some unchanged groups to compare the groups we changed, in regards to "throughput" of "Story Points" and quality of code, in regards to amount of bugs discovered before release.

We would also like to evaluate how long time each group used to solve a "issue" compared to the amount of "Story Points" 


\subsection{Expected contributions from the project}
\begin{itemize}
    \item How can you create an easy to understand GUI to make Finite State Automata's?
    \item How can the properties of a Finite State Automata help the customer make inquiries and innovation on requirements that might not be complete?
    \item How can automatic acceptance tests and precise defined requirements help developers deliver high quality within a reasonable time period?
\end{itemize}